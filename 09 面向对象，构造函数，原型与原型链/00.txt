1 创建对象的几种方式以及它们的有点和缺陷：
	1.1 传统模式：
		1.1.1  缺陷：传统创建多个相似对象过程中的代码重复问题
	1.2 工厂模式
		1.2.1 特点：解决了传统创建多个相似对象过程中的代码重复问题
		1.2.2 缺陷：
			1.2.2.1 无法识别对象实例的类型（这个用构造函数可以解决）
			1.2.2.2 当声明很多对象时，里面的方法被重新生成，但方法的功能是一样的。这就造成了不停为同一方法分配空间的浪费。(这个用原型解决)
	1.3 构造函数
		1.3.1 特点：解决了工厂模式的第一个缺陷
		1.3.2 缺陷：工厂模式的第二个缺陷依然存在
	1.4 原型
		1.4.1 特点：解决了工厂模式的第二个缺陷：重复为同一方法分配空间造成浪费。

-------------------------------------------------------------------------------------------------------------------------------------------

2 继承
	2.1 直接通过原型链实现继承
		2.1.1 定义：就是重写A引用类型的原型对象，代之以B引用类型的实例。引用类型A就继承了引用类型B
		2.1.2 缺陷
			2.1.2.1 通过原型实现继承时，原型实际上变成了另一个引用类型的实例。原有的实例属性会变成现有的原型属性，被所有实例所共享。就是说B引用类型实例变成了A引用类型的原型属性，被A引用类型的实例所共享。
			2.1.2.2 在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数
			
	2.2 组合继承
		2.2.1 定义：使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能保证每个实例拥有它自己的属性
		2.2.2 优点：解决了(2.1 直接通过原型链实现继承)的两个缺陷
		2.2.3 缺陷：无论什么声明情况下，都会调用两次超类型构造函数。一次是创建子类型原型的时候，另一次是在子类型构造函数内部。这也导致在子类型函数的原型内部含有不必要的多余的属性
		
	2.3 寄生组合式继承
		2.3.1 定义：通过借用构造函数来继承属性，通过原型链的混成模式来继承方法。其后的基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型的原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。
		2.3.2 特点：继承了组合继承的特点，也解决了组合继承的缺陷
		
-------------------------------------------------------------------------------------------------------------------------------------------
		
3 属性类型(移步绝对地址：F:\大前端\JavaScript进阶\9 面向对象，构造函数，原型与原型链\6 属性类型\000 .txt)
		(或移步相对地址：..\6 属性类型\000 .txt)

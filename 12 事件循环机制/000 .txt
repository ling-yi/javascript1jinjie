浏览器环境下（记住，是浏览器环境下，要区别于node环境），javascript中的事件循环机制要点：
	1 JavaScript的两个特点：
		1.1 JavaScript特点1：单线程。这意味着JavaScript代码在执行的任何时候，都只有一个主线程来处理所有的任务。单线程保证了程序执行的一致性
		1.2 JavaScript特点2：非阻塞。实现“非阻塞”的关键是事件队列。
	2 任务队列
		任务队列分为两种，分别是macro-task(宏任务)和micro-task(微任务)。
		macro-task包括：script(整体代码),setTimeout,setImmediate
		miceo-task包括：Promise,MutationObserver(html5新特性)
	3 事件循环机制
		当js引擎遇到一个异步事件后并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。
		以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。
		在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。
		重点记住：当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。
	4 每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。